import chess.svg

winner = False
score = 0
class Algorithms():
    global bestmove
    def __init__(self, board1):
        self.boardx = board1

    def minimax(self, board, isMax, depth, bestmove):
        if(winner == True):
            return bestmove
        if(depth == 0):
            return bestmove

        if isMax:
            bestscore = -10000

            for move in board.legal_moves:

                currentMove = chess.Move.from_uci(str(move))
                game = chessGame(board)
                if (currentMove in board.legal_moves):
                    board.push(currentMove)
                    Algorithms(board).minimax(board, False, depth - 1, bestmove)
                    if evaluateBoard(board) > bestscore:
                        bestscore = evaluateBoard(board)
                        bestmoveWhite = currentMove
                        bestmove = currentMove
                    board.pop()

            if (bestmoveWhite in board.legal_moves):
                bestmove = bestmoveWhite

            return bestmove


        else:
            bestscore = 10000


            for move in board.legal_moves:
                currentMove = chess.Move.from_uci(str(move))
                game = chessGame(board)
                if (currentMove in board.legal_moves):
                    board.push(currentMove)
                    Algorithms(board).minimax(board, True, depth - 1, bestmove)
                    if evaluateBoard(board) < bestscore:
                        bestscore = evaluateBoard(board)
                        bestmoveBlack = currentMove
                        bestmove = currentMove
                    board.pop()
            if (bestmoveBlack in board.legal_moves):
                bestmove = bestmoveBlack
            return bestmove



class chessGame():
    def __init__(self, board):
        self.board = board
        self = self

    # might remove, doesn't do anything rn
    def is_valid(self, move):
        legal_moves = list(boardx.legal_moves)  # creates list of legal moves
        for moves in legal_moves:  # checks if move is legal
            if moves == Nf3:
                return True
        return False


def evaluateBoard(board):
    count = 0
    # can't move your own king into checkmate, so this will return 1000 for a winning move for whoevers turn it is
    if board.is_checkmate():
        global winner
        winner = True
        if board.turn == False:  # return 1000 if white went last
            count += 1000
        else:  # return -1000 if black went last
            count -= 1000

    for s in range(64):
        # capital letters = white, lowercase = black
        piece = board.piece_at(getattr(chess, all_squares[s]))
        if str(piece) == 'P':
            count += 10
        elif str(piece) == 'p':
            count -= 10
        elif str(piece) == 'B' or str(piece) == 'N':
            count += 30
        elif str(piece) == 'b' or str(piece) == 'n':
            count -= 30
        elif str(piece) == 'R':
            count += 50
        elif str(piece) == 'r':
            count -= 50
        elif str(piece) == 'Q':
            count += 100
        elif str(piece) == 'q':
            count -= 100
        if s in (18, 19, 20, 21, 26, 27, 28, 29, 34, 35, 36, 37, 42, 43, 44, 45): #checks center squares (center control good)
            if str(piece) == 'P':
                count += 1
            elif str(piece) == 'p':
                count -= 1
            elif str(piece) == 'B':
                count += 2
            elif str(piece) == 'b':
                count -= 2
            elif str(piece) == 'N':
                count += 5
            elif str(piece) == 'n':
                count -= 5
            elif str(piece) == 'Q':
                count += 4
            elif str(piece) == 'q':
                count -= 4
    #TO DO: add hueristics for rook placement, castling, and fiencetto bishop
    return count


boardx = chess.Board()

Nf3 = chess.Move.from_uci("b1c3")
game = chessGame(boardx)
#if (game.is_valid(Nf3)):
 #   board.push(Nf3)  # Make the move
#board.pop()  # Unmake the last move
squares = (chess.A1, chess.A2)  # oh lord
#print(chess.RANK_NAMES + chess.FILE_NAMES)
# all_squares holds all squares
all_squares = []
for i in range(8):
    for j in range(8):
        all_squares.append((chess.FILE_NAMES[i].upper() + chess.RANK_NAMES[j]))
# for i in all_squares:
# print(i)
piece = boardx.piece_at(getattr(chess, all_squares[1]))
#print(list(board.legal_moves))
AI = Algorithms(boardx)
#print(evaluateBoard(boardx))
print('Would you like to go FIRST (enter 1) or SECOND (enter 2)')
first_or_second = input()
if int(first_or_second) == 1:
    while not boardx.is_game_over():


        print('Please enter your move (in format of current location of piece + desired location ex. a2a4')
        x = input()
        move = chess.Move.from_uci(str(x))
        if move in boardx.legal_moves:
            boardx.push(move)
        best_move = (AI.minimax(boardx, False, 2, None))
        move = chess.Move.from_uci(str(best_move))
        boardx.push(move)  # Make the move
        print(boardx)

        # displays gui in svg file
        board_svg = chess.svg.board(boardx, size=350)
        output_file = open('test.svg', "w")
        output_file.write(board_svg)
        output_file.close()
else:
    while not boardx.is_game_over():
        best_move = (AI.minimax(boardx, True, 2, None))
        move = chess.Move.from_uci(str(best_move))
        boardx.push(move)  # Make the move
        print(boardx)

        # displays gui in svg file
        board_svg = chess.svg.board(boardx, size=350)
        output_file = open('test.svg', "w")
        output_file.write(board_svg)
        output_file.close()

        print('Please enter your move (in format of current location of piece + desired location ex. a2a4')
        x = input()
        move = chess.Move.from_uci(str(x))
        boardx.push(move)




# displays gui in svg file
board_svg = chess.svg.board(boardx, size=350)
output_file = open('test.svg', "w")
output_file.write(board_svg)
output_file.close()
